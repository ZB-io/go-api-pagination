// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-vertex-claude using AI Type Vertex AI and AI Model claude-3-5-sonnet-v2

ROOST_METHOD_HASH=Paginator_7259a78d88
ROOST_METHOD_SIG_HASH=Paginator_37374faad1

 tasked with writing test scenarios for the Paginator function. Here are comprehensive test scenarios:

```
Scenario 1: Successful Single Page Pagination

Details:
  Description: Tests the basic functionality when there's only one page of results to process.
Execution:
  Arrange:
    - Create mock ListFunc returning a single page of items
    - Create mock ProcessFunc that processes items successfully
    - Create mock RateLimitFunc that returns true
    - Initialize PaginatorOpts with default values
  Act:
    - Call Paginator with mocked dependencies
  Assert:
    - Verify returned items match input items
    - Verify Process was called exactly once for each item
    - Verify RateLimit was called once
    - Verify no errors returned

Validation:
  This test ensures the basic happy path works correctly, processing a single page of results without pagination.
  Critical for validating core functionality without complexity of multiple pages.

---

Scenario 2: Multi-Page Pagination Success

Details:
  Description: Verifies correct handling of multiple pages of results with proper pagination.
Execution:
  Arrange:
    - Mock ListFunc returning multiple pages (using NextPage in Response)
    - Setup ProcessFunc to handle all items
    - Configure RateLimitFunc to return true
    - Set PaginatorOpts with initial page size
  Act:
    - Execute Paginator
  Assert:
    - Verify all items from all pages are returned
    - Confirm correct number of List calls
    - Validate Process called for each item
    - Check final page handling

Validation:
  Essential for testing the core pagination functionality, ensuring proper handling of multiple result pages.

---

Scenario 3: Rate Limit Interruption

Details:
  Description: Tests behavior when rate limit is reached during pagination.
Execution:
  Arrange:
    - Setup ListFunc with multiple pages
    - Configure RateLimitFunc to return false after first page
    - Create standard ProcessFunc
  Act:
    - Run Paginator
  Assert:
    - Verify only first page items returned
    - Confirm pagination stopped after rate limit
    - Validate no errors returned

Validation:
  Critical for API integration scenarios where rate limiting is common.

---

Scenario 4: List Function Error Handling

Details:
  Description: Verifies proper error handling when ListFunc fails.
Execution:
  Arrange:
    - Configure ListFunc to return error on second page
    - Setup standard ProcessFunc and RateLimitFunc
  Act:
    - Execute Paginator
  Assert:
    - Verify error is propagated
    - Confirm partial results returned
    - Validate process stopped at error

Validation:
  Important for resilience testing and error handling verification.

---

Scenario 5: Process Function Error Handling

Details:
  Description: Tests error propagation when ProcessFunc fails.
Execution:
  Arrange:
    - Setup normal ListFunc
    - Configure ProcessFunc to fail on specific item
    - Standard RateLimitFunc
  Act:
    - Run Paginator
  Assert:
    - Verify process error returned
    - Confirm partial results until error
    - Validate pagination stopped

Validation:
  Essential for verifying proper error handling during item processing.

---

Scenario 6: Context Cancellation

Details:
  Description: Verifies behavior when context is cancelled during pagination.
Execution:
  Arrange:
    - Setup context with cancellation
    - Configure normal ListFunc and ProcessFunc
    - Cancel context during execution
  Act:
    - Execute Paginator with cancelled context
  Assert:
    - Verify context cancellation error
    - Validate partial results
    - Confirm clean termination

Validation:
  Critical for testing proper context handling and graceful termination.

---

Scenario 7: Empty Result Set

Details:
  Description: Tests handling of zero results from ListFunc.
Execution:
  Arrange:
    - Configure ListFunc to return empty slice
    - Setup standard ProcessFunc and RateLimitFunc
  Act:
    - Run Paginator
  Assert:
    - Verify empty result slice
    - Confirm no Process calls
    - Validate normal termination

Validation:
  Important for edge case handling of empty result sets.

---

Scenario 8: Maximum Page Limit

Details:
  Description: Tests behavior with maximum page size configuration.
Execution:
  Arrange:
    - Set PaginatorOpts with maximum allowed page size
    - Configure ListFunc with large dataset
    - Standard ProcessFunc and RateLimitFunc
  Act:
    - Execute Paginator
  Assert:
    - Verify correct page size handling
    - Validate all items processed
    - Confirm proper pagination

Validation:
  Essential for testing pagination with large datasets and performance implications.
```

These scenarios cover the main functionality, error cases, and edge conditions of the Paginator function. Each scenario focuses on a specific aspect while maintaining isolation and clear validation criteria.
*/

// ********RoostGPT********
package pagination

import (
	"context"
	"errors"
	"github.com/google/go-github/v65/github"
	"testing"
)

// Mock implementations
type mockListFunc[T any] struct {
	items     [][]T
	responses []*github.Response
	err       error
	callCount int
}

func (m *mockListFunc[T]) List(_ context.Context, opt *github.ListOptions) ([]T, *github.Response, error) {
	if m.err != nil {
		return nil, nil, m.err
	}
	if m.callCount >= len(m.items) {
		return nil, &github.Response{}, nil
	}
	resp := m.responses[m.callCount]
	items := m.items[m.callCount]
	m.callCount++
	return items, resp, nil
}

type mockProcessFunc[T any] struct {
	err       error
	callCount int
}

func (m *mockProcessFunc[T]) Process(_ context.Context, _ T) error {
	m.callCount++
	return m.err
}

type mockRateLimitFunc struct {
	shouldContinue bool
	err           error
	callCount     int
}

func (m *mockRateLimitFunc) RateLimit(_ context.Context, _ *github.Response) (bool, error) {
	m.callCount++
	return m.shouldContinue, m.err
}

func TestPaginator(t *testing.T) {
	tests := []struct {
		name           string
		items         [][]string
		responses     []*github.Response
		listErr       error
		processErr    error
		rateLimitErr  error
		shouldContinue bool
		opts          *PaginatorOpts
		expectedItems int
		expectError   bool
		ctx           context.Context
	}{
		{
			name: "Successful Single Page",
			items: [][]string{{"item1", "item2"}},
			responses: []*github.Response{
				{NextPage: 0},
			},
			shouldContinue: true,
			expectedItems:  2,
			ctx:           context.Background(),
		},
		{
			name: "Multi-Page Success",
			items: [][]string{
				{"item1", "item2"},
				{"item3", "item4"},
			},
			responses: []*github.Response{
				{NextPage: 2},
				{NextPage: 0},
			},
			shouldContinue: true,
			expectedItems:  4,
			ctx:           context.Background(),
		},
		{
			name: "Rate Limit Interruption",
			items: [][]string{
				{"item1", "item2"},
				{"item3", "item4"},
			},
			responses: []*github.Response{
				{NextPage: 2},
			},
			shouldContinue: false,
			expectedItems:  2,
			ctx:           context.Background(),
		},
		{
			name:         "List Function Error",
			items:        [][]string{{"item1"}},
			listErr:      errors.New("list error"),
			expectError:  true,
			ctx:          context.Background(),
		},
		{
			name: "Process Function Error",
			items: [][]string{{"item1"}},
			responses: []*github.Response{
				{NextPage: 0},
			},
			processErr:   errors.New("process error"),
			expectError:  true,
			ctx:          context.Background(),
		},
		{
			name: "Context Cancellation",
			items: [][]string{{"item1"}},
			ctx: func() context.Context {
				ctx, cancel := context.WithCancel(context.Background())
				cancel()
				return ctx
			}(),
			expectError: true,
		},
		{
			name:          "Empty Result Set",
			items:         [][]string{{}},
			responses:     []*github.Response{{NextPage: 0}},
			expectedItems: 0,
			ctx:          context.Background(),
		},
		{
			name: "Maximum Page Size",
			items: [][]string{
				{"item1", "item2", "item3"},
			},
			responses: []*github.Response{
				{NextPage: 0},
			},
			opts: &PaginatorOpts{
				ListOptions: &github.ListOptions{
					PerPage: 3,
				},
			},
			shouldContinue: true,
			expectedItems:  3,
			ctx:           context.Background(),
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			listFunc := &mockListFunc[string]{
				items:     tt.items,
				responses: tt.responses,
				err:      tt.listErr,
			}
			processFunc := &mockProcessFunc[string]{
				err: tt.processErr,
			}
			rateLimitFunc := &mockRateLimitFunc{
				shouldContinue: tt.shouldContinue,
				err:           tt.rateLimitErr,
			}

			items, err := Paginator(tt.ctx, listFunc, processFunc, rateLimitFunc, tt.opts)

			if tt.expectError && err == nil {
				t.Error("expected error but got none")
			}
			if !tt.expectError && err != nil {
				t.Errorf("unexpected error: %v", err)
			}
			if len(items) != tt.expectedItems {
				t.Errorf("expected %d items, got %d", tt.expectedItems, len(items))
			}

			t.Logf("Test: %s", tt.name)
			t.Logf("Items returned: %d", len(items))
			t.Logf("List function called: %d times", listFunc.callCount)
			t.Logf("Process function called: %d times", processFunc.callCount)
			t.Logf("Rate limit function called: %d times", rateLimitFunc.callCount)
		})
	}
}
