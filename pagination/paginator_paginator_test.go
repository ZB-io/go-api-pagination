// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-vertex-claude using AI Type Vertex AI and AI Model claude-3-5-sonnet-v2

ROOST_METHOD_HASH=Paginator_7259a78d88
ROOST_METHOD_SIG_HASH=Paginator_37374faad1

FUNCTION_DEF=func Paginator[T any](ctx context.Context, listFunc ListFunc[T], processFunc ProcessFunc[T], rateLimitFunc RateLimitFunc, Opts *PaginatorOpts) ([]T, error)


I'll create test scenarios for the Paginator function based on the provided code and context:

```
Scenario 1: Successful Single Page Retrieval

Details:
  Description: Tests the basic functionality when there's only one page of results to retrieve.
Execution:
  Arrange:
    - Create mock ListFunc returning a single page of items
    - Create mock ProcessFunc that processes items successfully
    - Create mock RateLimitFunc that returns no rate limiting
    - Set up PaginatorOpts with default values
  Act:
    - Call Paginator with the mocked dependencies
  Assert:
    - Verify returned slice contains all items from the single page
    - Verify no errors returned
    - Verify Process was called for each item
Validation:
  Ensures basic pagination works when there's just one page of results.
  Validates the core happy path scenario.

Scenario 2: Multi-Page Retrieval

Details:
  Description: Tests pagination across multiple pages of results
Execution:
  Arrange:
    - Create mock ListFunc returning multiple pages (NextPage populated)
    - Create mock ProcessFunc that processes items successfully
    - Create mock RateLimitFunc allowing continuation
    - Set up PaginatorOpts with initial page settings
  Act:
    - Call Paginator with the mocked dependencies
  Assert:
    - Verify returned slice contains items from all pages
    - Verify no errors returned
    - Verify Process called for each item across all pages
Validation:
  Validates the core pagination functionality works across multiple pages.
  Ensures NextPage handling works correctly.

Scenario 3: List Function Error

Details:
  Description: Tests error handling when ListFunc fails
Execution:
  Arrange:
    - Create mock ListFunc that returns an error
    - Create standard ProcessFunc and RateLimitFunc
    - Set up basic PaginatorOpts
  Act:
    - Call Paginator with the error-producing ListFunc
  Assert:
    - Verify error is returned
    - Verify partial results are returned (if any were retrieved before error)
Validation:
  Ensures proper error handling when list operations fail.
  Validates the function's error propagation behavior.

Scenario 4: Process Function Error

Details:
  Description: Tests error handling when ProcessFunc fails
Execution:
  Arrange:
    - Create standard ListFunc returning valid items
    - Create mock ProcessFunc that returns an error
    - Create standard RateLimitFunc
  Act:
    - Call Paginator with the error-producing ProcessFunc
  Assert:
    - Verify processing error is returned
    - Verify partial results up to the error point are returned
Validation:
  Ensures proper error handling during item processing.
  Validates early termination on processing errors.

Scenario 5: Rate Limit Enforced

Details:
  Description: Tests behavior when rate limiting is enforced
Execution:
  Arrange:
    - Create standard ListFunc with multiple pages
    - Create standard ProcessFunc
    - Create RateLimitFunc that returns false after some iterations
  Act:
    - Call Paginator with rate-limiting enabled
  Assert:
    - Verify pagination stops when rate limit is hit
    - Verify partial results are returned successfully
Validation:
  Ensures rate limiting mechanism works correctly.
  Validates graceful handling of rate limit restrictions.

Scenario 6: Context Cancellation

Details:
  Description: Tests behavior when context is cancelled during pagination
Execution:
  Arrange:
    - Create cancellable context
    - Set up standard ListFunc, ProcessFunc, and RateLimitFunc
    - Cancel context during execution
  Act:
    - Call Paginator with cancelled context
  Assert:
    - Verify context cancellation error is returned
    - Verify partial results are returned
Validation:
  Ensures proper handling of context cancellation.
  Validates early termination on context cancellation.

Scenario 7: Empty Result Set

Details:
  Description: Tests behavior when no items are returned
Execution:
  Arrange:
    - Create ListFunc returning empty slice
    - Create standard ProcessFunc and RateLimitFunc
  Act:
    - Call Paginator with empty result set
  Assert:
    - Verify empty slice is returned
    - Verify no error is returned
Validation:
  Ensures proper handling of empty result sets.
  Validates edge case handling.

Scenario 8: Rate Limit Function Error

Details:
  Description: Tests error handling when RateLimitFunc fails
Execution:
  Arrange:
    - Create standard ListFunc and ProcessFunc
    - Create RateLimitFunc that returns an error
  Act:
    - Call Paginator with error-producing RateLimitFunc
  Assert:
    - Verify rate limit error is returned
    - Verify partial results are returned
Validation:
  Ensures proper error handling for rate limit function failures.
  Validates error propagation from rate limiting component.
```

These test scenarios cover the main functionality, error cases, and edge conditions of the Paginator function. They take into account the GitHub API pagination structure and rate limiting considerations while ensuring proper error handling and result accumulation.
*/

// ********RoostGPT********

package pagination

import (
	"context"
	"errors"
	"testing"
	"time"

	"github.com/google/go-github/v65/github"
)

type mockListFunc[T any] struct {
	items    []T
	nextPage int
	err      error
}
type mockProcessFunc[T any] struct {
	err error
}
type mockRateLimitFunc struct {
	shouldContinue bool
	err            error
}

func TestPaginator(t *testing.T) {
	type testItem struct {
		ID int
	}

	tests := []struct {
		name          string
		listFunc      ListFunc[testItem]
		processFunc   ProcessFunc[testItem]
		rateLimitFunc RateLimitFunc
		opts          *PaginatorOpts
		wantItems     []testItem
		wantErr       bool
		errMsg        string
	}{
		{
			name: "Successful Single Page Retrieval",
			listFunc: &mockListFunc[testItem]{
				items:    []testItem{{ID: 1}, {ID: 2}},
				nextPage: 0,
			},
			processFunc:   &mockProcessFunc[testItem]{},
			rateLimitFunc: &mockRateLimitFunc{shouldContinue: true},
			opts:          &PaginatorOpts{ListOptions: &github.ListOptions{Page: 1, PerPage: 10}},
			wantItems:     []testItem{{ID: 1}, {ID: 2}},
			wantErr:       false,
		},
		{
			name: "Multi-Page Retrieval",
			listFunc: &mockListFunc[testItem]{
				items:    []testItem{{ID: 1}, {ID: 2}},
				nextPage: 2,
			},
			processFunc:   &mockProcessFunc[testItem]{},
			rateLimitFunc: &mockRateLimitFunc{shouldContinue: true},
			opts:          &PaginatorOpts{ListOptions: &github.ListOptions{Page: 1, PerPage: 2}},
			wantItems:     []testItem{{ID: 1}, {ID: 2}},
			wantErr:       false,
		},
		{
			name: "List Function Error",
			listFunc: &mockListFunc[testItem]{
				err: errors.New("list error"),
			},
			processFunc:   &mockProcessFunc[testItem]{},
			rateLimitFunc: &mockRateLimitFunc{shouldContinue: true},
			opts:          &PaginatorOpts{ListOptions: &github.ListOptions{Page: 1}},
			wantItems:     nil,
			wantErr:       true,
			errMsg:        "list error",
		},
		{
			name: "Process Function Error",
			listFunc: &mockListFunc[testItem]{
				items: []testItem{{ID: 1}},
			},
			processFunc:   &mockProcessFunc[testItem]{err: errors.New("process error")},
			rateLimitFunc: &mockRateLimitFunc{shouldContinue: true},
			opts:          &PaginatorOpts{ListOptions: &github.ListOptions{Page: 1}},
			wantItems:     []testItem{{ID: 1}},
			wantErr:       true,
			errMsg:        "process error",
		},
		{
			name: "Rate Limit Error",
			listFunc: &mockListFunc[testItem]{
				items: []testItem{{ID: 1}},
			},
			processFunc:   &mockProcessFunc[testItem]{},
			rateLimitFunc: &mockRateLimitFunc{err: errors.New("rate limit error")},
			opts:          &PaginatorOpts{ListOptions: &github.ListOptions{Page: 1}},
			wantItems:     []testItem{{ID: 1}},
			wantErr:       true,
			errMsg:        "rate limit error",
		},
		{
			name: "Empty Result Set",
			listFunc: &mockListFunc[testItem]{
				items: []testItem{},
			},
			processFunc:   &mockProcessFunc[testItem]{},
			rateLimitFunc: &mockRateLimitFunc{shouldContinue: true},
			opts:          &PaginatorOpts{ListOptions: &github.ListOptions{Page: 1}},
			wantItems:     []testItem{},
			wantErr:       false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ctx := context.Background()

			got, err := Paginator(ctx, tt.listFunc, tt.processFunc, tt.rateLimitFunc, tt.opts)

			if (err != nil) != tt.wantErr {
				t.Errorf("Paginator() error = %v, wantErr %v", err, tt.wantErr)
				return
			}

			if tt.wantErr && err != nil && err.Error() != tt.errMsg {
				t.Errorf("Paginator() error message = %v, want %v", err.Error(), tt.errMsg)
				return
			}

			if len(got) != len(tt.wantItems) {
				t.Errorf("Paginator() got %v items, want %v items", len(got), len(tt.wantItems))
				return
			}

			for i := range got {
				if got[i].ID != tt.wantItems[i].ID {
					t.Errorf("Paginator() got item[%d] = %v, want %v", i, got[i], tt.wantItems[i])
				}
			}

			t.Logf("Test '%s' completed successfully", tt.name)
		})
	}
}
func (m *mockListFunc[T]) List(ctx context.Context, opt *github.ListOptions) ([]T, *github.Response, error) {
	if m.err != nil {
		return nil, nil, m.err
	}
	resp := &github.Response{
		NextPage: m.nextPage,
		Response: nil,
		Rate: github.Rate{
			Limit:     5000,
			Remaining: 4999,
			Reset:     github.Timestamp{Time: time.Now().Add(time.Hour)},
		},
	}
	return m.items, resp, nil
}
func (m *mockProcessFunc[T]) Process(ctx context.Context, item T) error {
	return m.err
}
func (m *mockRateLimitFunc) RateLimit(ctx context.Context, resp *github.Response) (bool, error) {
	if m.err != nil {
		return false, m.err
	}
	return m.shouldContinue, nil
}
